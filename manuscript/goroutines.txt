# Chapter 12: Goroutines and Concurrency in Go

The world of Go is not just about data types, variables, functions, and control structures. Go introduces a unique way of handling concurrency using Goroutines. Concurrency allows our programs to perform multiple tasks independently, thereby making them more efficient. This chapter explores the basics of goroutines and the power they bring to concurrent programming in Go.

## 12.1 What are Goroutines?

Goroutines are functions or methods that run concurrently with other functions or methods. They are lightweight threads of execution managed by the Go runtime. A goroutine is started by following a function call with the keyword `go`. For instance:

```go
func main() {
    go printPodDetails("pod-1")
}
```

Here, `printPodDetails` is executed in a new goroutine. The `main()` function does not wait for `printPodDetails` to complete; it continues to the next line of code.

## 12.2 Working with Multiple Goroutines

In a Kubernetes context, imagine we have a list of pods and we want to fetch their details concurrently. Here's how we can do that with goroutines:

```go
func main() {
    pods := []string{"pod-1", "pod-2", "pod-3"}

    for _, pod := range pods {
        go printPodDetails(pod)
    }
}
```

This code starts a new goroutine for each pod in the `pods` slice. However, there is a catch here. The `main()` function does not wait for these goroutines to complete execution, which means the program might terminate before any of these goroutines can run.

## 12.3 Goroutines and Synchronization

To synchronize the execution of goroutines, Go provides a powerful and easy-to-use synchronization primitive known as the `WaitGroup` from the `sync` package. 

```go
func main() {
    pods := []string{"pod-1", "pod-2", "pod-3"}
    var wg sync.WaitGroup

    for _, pod := range pods {
        wg.Add(1)
        go func(pod string) {
            defer wg.Done()
            printPodDetails(pod)
        }(pod)
    }

    wg.Wait()
}
```

Here, we're using a `WaitGroup` to ensure that our `main()` function does not exit until all our goroutines have finished executing.

The `Add` method adds the number of goroutines to wait for, the `Done` method signals the completion of a goroutine, and the `Wait` method blocks until all goroutines have finished.

## 12.4 Conclusion

In this chapter, we've touched upon the powerful concept of goroutines in Go. We learned how to spawn goroutines and synchronize their execution using `WaitGroup`. As we move forward in our journey with Go, it's essential to understand and leverage goroutines to write highly efficient and concurrent programs. In the next chapter, we'll dive into channels, which provide a way for goroutines to communicate with each other and synchronize their execution.
